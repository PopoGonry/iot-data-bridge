# IoT Data Bridge 프로젝트 요구사항 및 의사결정 사항

## 📋 프로젝트 개요
- **프로젝트명**: IoT Data Bridge
- **목적**: 외부 데이터를 Object로 매핑하고 Device(VM)에 전달하는 파이썬 기반 미들웨어
- **아키텍처**: 6개 레이어 구조 (Input → Mapping → Resolver → Transports → Logging)

---

## 🛠️ 기술 스택 및 프레임워크 (추천)

### **Python 버전**
- **추천**: Python 3.11
- **이유**: 최신 성능 개선, asyncio 안정성, 타입 힌트 지원

### **MQTT 클라이언트**
- **추천**: `aiomqtt`
- **이유**: asyncio 네이티브 지원, 비동기 처리에 최적화

### **SignalR 클라이언트**
- **추천**: `signalrcore`
- **이유**: Python에서 가장 안정적인 SignalR 클라이언트

### **웹 프레임워크**
- **추천**: 순수 asyncio (웹 프레임워크 없음)
- **이유**: 
  - 기획서상 관리 API 요구사항 없음
  - MQTT/SignalR만으로 입출력 처리
  - 단순성과 성능 우선

### **데이터베이스**
- **추천**: 메모리 기반 (dict, asyncio.Queue)
- **이유**: 
  - 실시간 처리에 최적화
  - 외부 의존성 최소화
  - 설정은 YAML 파일로 관리

### **로깅**
- **추천**: Python `logging` + `structlog`
- **이유**: 
  - 구조화된 로그 (JSON 형태)
  - 성능과 가독성 균형
  - 표준 라이브러리 기반

---

## ⚙️ 설정 및 구성 관리 (추천)

### **설정 파일 형식**
- **추천**: YAML
- **이유**: 가독성, 중첩 구조 표현 용이, 기획서 예시와 일치

### **동적 설정 변경**
- **추천**: 파일 기반 (재시작 필요)
- **이유**: 
  - 초기 버전은 단순성 우선
  - 나중에 필요시 API 추가 가능

### **설정 검증**
- **추천**: Pydantic 모델 사용
- **이유**: 타입 안정성, 자동 검증, IDE 지원

---

## 🚨 에러 처리 및 복구 (추천)

### **네트워크 장애**
- **추천**: 자동 재연결 + 지수 백오프
- **구현**: 
  ```python
  async def reconnect_with_backoff():
      delay = 1
      while True:
          try:
              await connect()
              break
          except Exception:
              await asyncio.sleep(delay)
              delay = min(delay * 2, 60)
  ```

### **매핑 실패**
- **추천**: 로그 기록 후 스킵
- **이유**: 일부 데이터 오류가 전체 시스템 중단을 유발하지 않도록

### **전송 실패**
- **추천**: 3회 재시도 후 포기
- **이유**: 일시적 네트워크 문제와 영구적 오류 구분

### **데드레터 큐**
- **추천**: 초기 버전에서는 미구현
- **이유**: 단순성 우선, 필요시 나중에 추가

---

## ⚡ 성능 및 확장성 (추천)

### **동시 처리**
- **추천**: asyncio 기반 비동기 처리
- **예상 처리량**: 1000+ msg/sec (하드웨어에 따라)

### **메시지 큐**
- **추천**: asyncio.Queue 사용
- **이유**: 
  - 외부 의존성 없음
  - Python 네이티브 성능
  - 단순한 구조

### **배치 처리**
- **추천**: 개별 메시지 처리
- **이유**: 실시간성 우선, 지연 시간 최소화

### **모니터링**
- **추천**: 초기 버전에서는 로그 기반
- **이유**: 단순성 우선, 필요시 Prometheus 등 추가

---

## 🔒 보안 (추천)

### **인증**
- **추천**: MQTT/SignalR 연결 시 기본 인증
- **구현**: 사용자명/비밀번호 또는 토큰 기반

### **암호화**
- **추천**: TLS/SSL 사용
- **이유**: 프로덕션 환경에서 필수

### **API 보안**
- **추천**: 초기 버전에서는 관리 API 없음
- **이유**: 단순성 우선

---

## 🚀 운영 및 배포 (추천)

### **컨테이너화**
- **추천**: 컨테이너화 하지 않음
- **이유**: 단순성 우선, 직접 실행 방식

### **프로세스 관리**
- **추천**: systemd (Linux) 또는 supervisor
- **이유**: 자동 재시작, 로그 관리

### **로그 수집**
- **추천**: 파일 기반 + 로테이션
- **구현**: Python logging + logrotate

### **헬스체크**
- **추천**: 간단한 파일 기반 체크
- **구현**: 주기적으로 상태 파일 업데이트

---

## 🧪 개발 및 테스트 (추천)

### **테스트 전략**
- **추천**: pytest + asyncio 테스트
- **범위**: 
  - 단위 테스트: 각 레이어별
  - 통합 테스트: 전체 플로우
  - 모킹: MQTT/SignalR 클라이언트

### **개발 환경**
- **추천**: Docker Compose + 개발용 설정
- **구성**: 
  - MQTT 브로커 (Eclipse Mosquitto)
  - SignalR Hub (간단한 테스트용)
  - 로그 모니터링

### **문서화**
- **추천**: README + 설정 가이드
- **내용**: 
  - 설치 및 실행 방법
  - 설정 파일 예시
  - 로그 형식 설명

---

## 📊 데이터 형식 및 검증 (추천)

### **입력 데이터 검증**
- **추천**: Pydantic 모델 사용
- **구현**: 
  ```python
  class IngressEvent(BaseModel):
      trace_id: str
      raw: dict
      meta: dict
  ```

### **값 타입 캐스팅**
- **추천**: 실패 시 로그 기록 후 스킵
- **이유**: 데이터 무결성 유지

### **메시지 크기 제한**
- **추천**: 1MB 제한
- **이유**: 메모리 보호, 네트워크 효율성

---

## 🎯 특별 요구사항 (추천)

### **실시간성**
- **추천**: < 100ms 지연 시간 목표
- **구현**: 비동기 처리 + 최소한의 큐잉

### **순서 보장**
- **추천**: 메시지별 순서 보장 (같은 trace_id 내)
- **구현**: asyncio.Lock 사용

### **중복 제거**
- **추천**: trace_id 기반 중복 제거
- **구현**: 메모리 기반 캐시 (TTL 적용)

---

## 📁 프로젝트 구조 (추천)

```
iot-data-bridge/
├── src/
│   ├── main.py              # 메인 애플리케이션
│   ├── layers/              # 각 레이어 구현
│   ├── catalogs/            # 매핑 및 Device 카탈로그
│   ├── models/              # 데이터 모델
│   └── utils/               # 유틸리티
├── config/                  # 설정 파일
├── scripts/                 # 실행 스크립트
├── tests/                   # 테스트
└── logs/                    # 로그 파일
```

---

## 🎯 구현 우선순위

### **Phase 1: 핵심 기능**
1. 기본 레이어 구조 구현
2. MQTT Input Layer
3. Mapping Layer + Catalog
4. 기본 로깅

### **Phase 2: 전송 기능**
1. MQTT Transports Layer
2. Device Catalog
3. Resolver Layer

### **Phase 3: 고도화**
1. SignalR 지원
2. 에러 처리 강화
3. 모니터링 추가

### **Phase 4: 운영 기능**
1. 시스템 서비스 등록 (systemd/supervisor)
2. 설정 관리 개선
3. 테스트 커버리지 확대

---

## ❓ 추가 검토 필요 사항

1. **실제 운영 환경의 메시지 볼륨**은 어느 정도인가요?
2. **Device(VM)의 수**는 대략 몇 개 정도인가요?
3. **Object의 종류**는 대략 몇 개 정도인가요?
4. **실시간성 요구사항**이 정말 중요한가요?
5. **장애 복구 시간**은 어느 정도까지 허용 가능한가요?

이 문서를 기반으로 구현을 진행하시겠습니까? 특정 부분에 대한 수정이나 추가 요구사항이 있으시면 말씀해 주세요.
